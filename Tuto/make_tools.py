
# coding: utf-8

# # Make tools for AMEDA

# This subroutine is run before <i>Tuto_AMEDA</i> to build the environment and the tools
# * Pre-processing tools get_netcdf.sh and make_nc_file.m
# * AMEDA code and tools
# * Post-processing tools plot_tracking.m and plot_tracking_SST.m

# ## Download AMEDA code and tools

# * Use git to get AMEDA code from https://github.com/briaclevu/AMEDA.git in $workdir
# * or you can download a stable version of the code from https://www.lmd.polytechnique.fr/dyned/
# * or just ask to briac.le-vu@lmd.polytechnique.fr
# 
# or
# 
# * copy from local directories

# In[5]:

get_ipython().magic('mkdir $workdir/sources')
get_ipython().magic('cp -r /home/blevu/MATLAB/AMEDA/sources/*m $workdir')
get_ipython().magic('cp -r /home/blevu/MATLAB/AMEDA/tools $workdir')
get_ipython().magic('cp /home/blevu/MATLAB/start_Tuto.m $homedir/start.m')
get_ipython().magic('cp -r /home/blevu/MATLAB/Rossby_radius $datadir')


# ## Create <i>keys_sources</i> parameters and MAIN routine of AMEDA

# <b>Define configuration with domain and keys</b>

# In[ ]:

get_ipython().run_cell_magic('writefile', '{homedir}AMEDA/keys_sources_AVISO_Tuto.m', "% keys_sources_AVISO.m\n%\n%   keys_sources sets user defined paths and user keys\n%\n% Paths:\n%   - path_in: directory containing the input files;\n%              (default is '..\\Data\\')\n%   - path_out: directory for the output files;\n%              (default is '..\\Tracks\\')\n%   - nc_u: full name of the netcdf file with the zonal component of\n%           velocity (ssu) and the time index (day)\n%   - nc_v: full name of the netcdf file with the meridional component of\n%           velocity (ssv) and the time index (day)\n%   - nc_dim: full name of the netcdf file with the domain coordinates \n%            (longitude and latitude) and the velocity mask (land-points=0;\n%             ocean-points=1)\n%\n% User option keys:\n%   - type_detection: flag to choose the field use as streamlines\n%           1 : using velocity fields\n%           2 : using ssh\n%           3 : using both velocity fields and ssh for eddy contour, \n%               and keep the contour of the last one if it existS.\n%   - extended_diags: flag to have extra diags concerning eddies directly\n%       computed (like ellipse features or vorticity for each eddy)\n%           0 : not computed\n%           1 : computed as the same time as eddy detection\n%           2 : computed afterward\n%   - streamlines and daystreamfunction: save streamlines at steps \n%       'daystreamfunction' and profils of streamlines scanned as well\n%       (1:stepF by default )\n%   - periodic: flag to activate options for East-West periodic\n%               (e.g. global fields or idealized simulations) domains.\n%               IMPORTANT: first and last columns of the domain must be\n%                          identical for this to work properly!!!!!\n%   - nrt: used in Near real time mode to flag to activate no filtration\n%       of short eddies at the end and at the beginning of the tracking\n%\n%-------------------------\n% IMPORTANT - Input file requirements:\n%\n% All the variables are read from netcdf file.\n% The package requires 3 different input files:\n% 1) nc_dim with variables x(j,i),y(j,i),mask(j,i)\n% 2) nc_u with variable ssu(t,j,i), day(t)\n% 3) nc_v with variable ssv(t,j,i), day(t)\n%\n% t is the temporal dimension (number of time steps)\n% j is the zonal dimension (number of grid points along y or latitude)\n% i is the meridional dimension (number of grid points along x or longitude)\n%\n% The grid is assumed to be rectangular, with orientation N-S and E-W. \n% Grid indices correspond to geography, so that point (1,1) represents the\n%      south-western corner of the domain.\n% Latitudinal and longitudinal grid spacing can vary within the grid domain.\n%\n%-------------------------\n%   Ver Jun 2018 Briac and Romain Pennel\n%   Ver Apr 2015 Briac Le Vu\n%   Ver. 2.1 Oct.2012\n%   Ver. 2.0 Jan.2012\n%   Ver. 1.3 Apr.2011\n%   Ver. 1.2 May.2010\n%   Ver. 1.1 Dec.2009\n%   Authors: Francesco Nencioli, francesco.nencioli@univ-amu.fr\n%            Charles Dong, cdong@atmos.ucla.edu\n%\n%-------------------------\n%   June 2016 Briac Le Vu\n%-------------------------\n%\n%=========================\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% User modification ---------------------------------------------\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n%% Experiment setings\n%----------------------------------------------\n\n% source of the input\nsource='AVISO';\n\n% set name of the domain\ndomain='MED';\n\n% config\nconfig='nrt';\n\n% use to diferenciate source field of surface height (adt, ssh, psi,...)\nsshtype='adt'; % adt or sla\n\n% use to differenciate job\nrunname = '';\n\n% set the paths\npath_in=['./DATA/',source,'/',domain,'/'];\n\n% postfix name of the data\nM = textread([path_in,'../../date.txt'],'%s');\npostname = [num2str(M{1}),'_',num2str(M{end})];\n\npath_out=['./RESULT/',domain,'_',postname,'/'];\npath_tracks='./DATA/AVISO/tracks/';\npath_rossby='./DATA/Rossby_radius/';\n\ndisp(['Compute from ',path_in])\ndisp([' to ',path_out])\n\nif exist(path_out,'file')==0\n    system(['mkdir ',path_out]);\nend\n\n% add path_out path\naddpath(path_out)\n\n% input data file absolute name\nnc_dim=[path_in,'lon_lat_',domain,'.nc'];\nnc_u=[path_in,'ssu_',config,'_',domain,'_',postname,'.nc'];\nnc_v=[path_in,'ssv_',config,'_',domain,'_',postname,'.nc'];\nnc_ssh=[path_in,'ssh_',config,'_',domain,'_',postname,'.nc'];\n\n% Rossby deformation radius file\nmat_Rd = [path_rossby,'Rossby_radius'];\nname_Rd = 'Rd_baroc1_extra';\n\n% searched eddies typical radius\n% eddies smaller than 1/4 this radius will be smoothed\nRd_typ = 12;% km\n\n% minimal size for rmax to be reasonably detected\nnRmin = 1/2; % half of the native Dx grid size\n\n% variable names (could be automatised)\ny_name = 'lat';\nx_name = 'lon';\nm_name = 'mask';\nu_name = 'u';\nv_name = 'v';\ns_name = 'ssh';\n\n% duration experiment (should read a 'time' variable)\nif ~exist('stepF','var')\n    u0 = squeeze(ncread(nc_u,u_name,[1 1 1],[1 1 Inf]));\n    stepF = length(u0);\n    clear u0\nend\n\ndisp([' ',num2str(stepF),' time steps'])\ndisp(' ')\n\n% rotation period (T) per day and time step in days (dps)\nT = 3600*24; % day period in seconds\ndps = 1; % 24h time step\nlevel=1;\n\n% degradation factor to test the algorithm\nif ~exist('deg','var')\n    deg = 1; % from 1 (default) to >10 in some experiment\nend\n\n%% Experiment option keys\n%----------------------------------------------\n\n% grid type\ngrid_ll = 1;\n        % 0 : spatial grid in cartesian coordinates (x,y)\n        % 1 : spatial grid in earth coordinates (lon,lat)\n\n% grid regular or not (like arakawa in NEMO)\ngrid_reg = 1;\n        % 0 irregular \n        % 1 regular \n\n% choose the field use as streamlines\ntype_detection = 1;\n        % 1 : using velocity fields\n        % 2 : using ssh\n        % 3 : using both velocity fields and ssh, \n        %     and keep max velocity along the eddy contour\n\n% if you want extended diags directly computed\nextended_diags = 1;\n        % 0 : not computed\n        % 1 : computed as the same time as eddy detection\n        % 2 : computed afterward  \n\n% save streamlines at days daystreamfunction and profil as well\nstreamlines = 1;\ndaystreamfunction = 1:stepF;\n\n% in case of periodic grid along x boundaries\nperiodic = 0;\n\n% to keep firts and last detection after the tracking in NRT configuration\nnrt = 1;\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% End of user modification ---------------------------------------------\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%")


# <b>Create MAIN routine to run AMEDA</b>

# In[ ]:

get_ipython().run_cell_magic('writefile', '{homedir}AMEDA/MAIN_AMEDA_Tuto.m', "%MAIN_AMEDA\n%\n%   MAIN_AMEDA is the main function of the eddy detection and\n%   tracking package. It returns position of the centers, dimensions and \n%   tracks of the eddies detected from the time series of a 2-D velocity \n%   field.\n%   It gives also an history of the splitting and merging events.\n%\n%   - 'source' allows to specify the type of sources file (AVISO, ROMS, NEMO,...)\n%     with their specific parameters and Input/Output.\n%   - cpus to use 'parfor' as time loops (=# of processors)\n%       cpus = 1 (default)\n%   - update is a flag allowing to update an existing tracking:\n%       update = number of time steps backward to consider\n%       update = 0 (default) to compute all the time serie\n%   - stepF is the last time step computed\n%       stepF = temporal size of the input data\n%\n%   The algortihm subroutines:\n%\n%   - mod_eddy_params sets user defined paths and parameters:\n%     nc_u nc_v nc_dim b bx r path_in path_out periodic criteres\n%     Users should modify keys_sources.m according to their \n%     settings.\n%\n%   - mod_init initialise or update mat-file.\n%\n%   - mod_fields compute LNAM.\n%\n%   - mod_eddy_centers returns a structure array with the position of the\n%     detected eddy centers.\n%\n%   - mod_eddy_shapes computes dimensions for the detected eddy centers.\n%\n%   - mod_eddy_tracks computes eddy tracks using the detected centers.\n%\n%   Find the output files in path_out:\n%\n%   - fields.mat contains detection_fields with LNAM for each step.\n%   - eddy_centers.mat contains for each step:\n%       * centers0 as the local max(LNAM)\n%       * centers as the potential centers\n%       * centers2 as the detected eddies\n%   - eddy_shapes.mat contains for each step:\n%       * shapes1 the eddy features\n%       * shapes2 the common double contour features\n%       * profil2 the streamlines features scanned around each eddy\n%       * warn_shapes the flag for potential centers\n%       * warn_shapes2 the flag for detected eddies\n%   - eddy_tracks.mat contains eddy centers, features and flags for each eddy\n%\n%-------------------------\n%   June 2016 Briac Le Vu\n%-------------------------\n%\n%=========================\n\nstart\nclear; clc;\n\n%----------------------------------------\n% source of data driving the netcdf format\nsource = 'AVISO';\n\n%----------------------------------------\n% config\nkeys = 'Tuto';\n\n%----------------------------------------\n% Update option\nupdate = 0; % the serie from the begenning\n\n%----------------------------------------\n% Possibility to shorter the serie\n%stepF = 10;\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% Initialisation ---------------------------------------------\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n%----------------------------------------\n% Produce default parameters in param_eddy_tracking\nif exist('stepF','var')\n    mod_eddy_params(['keys_sources_',source,'_',keys],stepF)\nelse\n    mod_eddy_params(['keys_sources_',source,'_',keys])\nend\nrun(['keys_sources_',source,'_',keys])\nload('param_eddy_tracking','path_out','streamlines','resol','stepF');\n\n%----------------------------------------\n% Preallocate structure array and mat-file or prepare update\n% !! replace or reinitialise previous results !!\nstep0 = mod_init(stepF,update);\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% Compute LNAM ---------------------------------------------\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ndisp(' === Compute non interpolated LNAM ===')\ndisp(' ')\n\nload([path_out,'fields'],'detection_fields')\n\nfor stp = step0:stepF\n    %----------------------------------------\n    % Compute non interpolated fields for step stp\n    detection_fields(stp) = mod_fields(source,stp,1);\nend\n\n%----------------------------------------\n% Save non interpolated fields\nsave([path_out,'fields'],'detection_fields','-v7.3')\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% Compute interpolated LNAM ---------------------------------------------\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nif resol>1\n    disp(' === Compute interpolated LNAM ===')\n    disp(' ')\n    \n    load([path_out,'fields_inter.mat'],'detection_fields')\n    \n    for stp = step0:stepF\n        %----------------------------------------\n        % Compute interpolated fields for step stp\n        detection_fields(stp) = mod_fields(source,stp,resol);\n    end\nelse\n    %----------------------------------------\n    % Interpolated and non interpolated field are the same\n    disp(' === Interpolated LNAM is the same ===')\nend\n\n%----------------------------------------\n% Save interpolated fields\nsave([path_out,'fields_inter'],'detection_fields','-v7.3')\nclear detection_fields\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% Find centers ---------------------------------------------\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ndisp(' === Find potential centers ===')\ndisp(' ')\n\nload([path_out,'eddy_centers'],'centers0','centers')\n\n%----------------------------------------\n% Build I/O matfile\nfields_mat = matfile([path_out,'fields_inter.mat']);\n\nfor stp = step0:stepF\n    % load inter fields at step stp\n    %----------------------------------------\n    fields = fields_mat.detection_fields(:,stp);\n    %----------------------------------------\n    % Detection of eddy centers for step stp\n    [centers0(stp),centers(stp)] = mod_eddy_centers(source,stp,fields);\nend\n\n%----------------------------------------\n% Save centers\nsave([path_out,'eddy_centers'],'centers0','centers','-append')\nclear centers0 centers\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% Find eddies ---------------------------------------------\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ndisp(' === Determine eddies shapes ===')\ndisp(' ')\n\nload([path_out,'eddy_centers'],'centers2')\nload([path_out,'eddy_shapes'])\n\n%----------------------------------------\n% Build I/O matfile\ncenters_mat = matfile([path_out,'eddy_centers.mat']);\nfields_mat = matfile([path_out,'fields_inter.mat']);\n\nfor stp = step0:stepF\n    if isempty(centers2(stp).step)\n        %----------------------------------------\n        % load fields at step stp\n        fields = fields_mat.detection_fields(:,stp);\n        %----------------------------------------\n        % load potential centers at step stp\n        centers = centers_mat.centers(:,stp);\n        %----------------------------------------\n        % Determination of eddy features for step stp\n        if streamlines\n            [centers2(stp),shapes1(stp),shapes2(stp),profil2(stp),...\n                warn_shapes(stp),warn_shapes2(stp)] = ...\n                mod_eddy_shapes(source,stp,fields,centers);\n        else\n            [centers2(stp),shapes1(stp),shapes2(stp),~,...\n                warn_shapes(stp),warn_shapes2(stp)] = ...\n                mod_eddy_shapes(source,stp,fields,centers);\n        end\n    end\nend\n\n%----------------------------------------\n% save warnings, shapes and their centers\nsave([path_out,'eddy_centers'],'centers2','-append')\nif streamlines\n    save([path_out,'eddy_shapes'],'shapes1','shapes2',...\n        'warn_shapes','warn_shapes2','profil2','-v7.3')\nelse\n    save([path_out,'eddy_shapes'],'shapes1','shapes2',...\n        'warn_shapes','warn_shapes2','-v7.3')\nend\nclear centers2 shapes1 shapes2 profil2 warn_shapes warn_shapes2 struct1 struct2 struct3\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% Track eddies ---------------------------------------------\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n%----------------------------------------\n% Tracking eddiesand record interacting events\nmod_eddy_tracks_nopool('',update)\n\n%----------------------------------------\n% Resolve merging and spltting event and filter eddies shorter than cut_off\nmod_merging_splitting('');")


# ## Create tools for data pre-processing

# <b><i>get_aviso.sh</i> to download AVISO data</b>

# In[1]:

get_ipython().run_cell_magic('writefile', '{datadir}get_aviso.sh', '#!/bin/bash\n# get the daily AVISO merged dataset to produce nc file\n\nUSER=*              #This is the FTP user that has access to the server.\nPASS=*           #This is the password for the FTP user.\nHOST1=my.cmems-du.eu    #Host for DT\nHOST2=nrt.cmems-du.eu   #Host for NRT\n\nn=$(cat date.txt | wc -l)\nyyyymmdd1=$(sed -n "1 p" date.txt)\nyyyymmdd2=$(sed -n "$n p" date.txt)\n\nmkdir AVISO\ncd AVISO\nmkdir phy_l4\ncd phy_l4\nmkdir allsat\ncd allsat\n\nwhile read -r line\ndo\n    \n    YEAR=`echo $line | cut -b1-4`\n    MONTH=`echo $line | cut -b5-6`\n  \n    hostdir1=Core/SEALEVEL_MED_PHY_L4_REP_OBSERVATIONS_008_051/dataset-duacs-rep-medsea-merged-allsat-phy-l4/${YEAR}/${MONTH}\n    hostdir2=Core/SEALEVEL_MED_PHY_L4_NRT_OBSERVATIONS_008_050/dataset-duacs-nrt-medsea-merged-allsat-phy-l4/${YEAR}/${MONTH}\n    \n    # remove old file\n    rm dt_med_allsat_phy_l4_${line}*\n\n    # get the daily DT file from CMEMS\n     wget -r -nd ftp://$USER:$PASS@${HOST1}/${hostdir1}/dt_med_allsat_phy_l4_${line}_*.nc\n\n    if [ ! -f "dt_med_allsat_phy_l4_${line}*" ]; then\n\n        # remove old file\n        rm nrt_med_allsat_phy_l4_${line}*\n\n        # get the daily NRT file from CMEMS\n        wget -r -nd ftp://$USER:$PASS@${HOST2}/${hostdir2}/nrt_med_allsat_phy_l4_${line}_*.nc\n                \n    fi\n\ndone < ../../../date.txt\n\n/opt/cdo-1.6.3/bin/cdo -f nc copy dt_med_allsat_phy_l4_${YEAR}* ../dt_med_allsat_phy_l4_${yyyymmdd1}_${yyyymmdd2}.nc\n/opt/cdo-1.6.3/bin/cdo -f nc copy nrt_med_allsat_phy_l4_${YEAR}* ../nrt_med_allsat_phy_l4_${yyyymmdd1}_${yyyymmdd2}.nc\n\ncd ../../..')


# <b><i>make_nc_file.m</i> to convert AVISO to AMEDA file format</b>

# In[ ]:

get_ipython().run_cell_magic('writefile', '{datadir}mk_nc_file.m', "% Arrange and rename mapped data field coming from CMEMS website \n% to be computed in mod_eddy_* routines\n\nclear all\nclose all\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%% User modifications\ndomname='MED';\n\ndirin=['./AVISO/phy_l4/'];\n\ndirout=['./AVISO/',domname,'/'];\n\nsystem(['mkdir ',dirout])\n\n% data from aviso.altimetry.fr\ninname='dt_med_allsat_phy_l4';\n\nM=textread('./date.txt');\ndatename=['_',num2str(M(1)),'_',num2str(M(end))];\n\n% build outfile name\noutname=['nrt_',domname,datename];\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% Get the fields (lon,lat,time, ssh, u and v)\nssh=ncread([dirin,inname,datename,'.nc'],'adt');\nu=ncread([dirin,inname,datename,'.nc'],'ugos');\nv=ncread([dirin,inname,datename,'.nc'],'vgos');\n\ntime=ncread([dirin,inname,datename,'.nc'],'time');\nlon=ncread([dirin,inname,datename,'.nc'],'longitude');\nlat=ncread([dirin,inname,datename,'.nc'],'latitude');\n\n% area med\nlon1=-6-360;\nlon2=37-360;\nlat1=30;\nlat2=46;\n\n% Resize for the selected area\nu1=u((lon>=lon1+360 & lon<=lon2+360),(lat>=lat1 & lat<=lat2)',:);\n\n[N1,M1,L1]=size(u1);\nmask1=squeeze(u1(:,:,1)*0+1);\nmask1(isnan(mask1))=0;\n\n% Arrange longitude (360 -> OE)\nlon2d=double(repmat(lon(lon>=lon1+360 & lon<=lon2+360),[1 M1]));\nlat2d=double(repmat(lat(lat>=lat1 & lat<=lat2)',[N1 1]));\n\n% Create grid file\nnccreate([dirout,'lon_lat_MED.nc'],'lon','Dimensions',{'x' N1 'y' M1});\nnccreate([dirout,'lon_lat_MED.nc'],'lat','Dimensions',{'x' N1 'y' M1});\nnccreate([dirout,'lon_lat_MED.nc'],'mask','Dimensions',{'x' N1 'y' M1});\nncwrite([dirout,'lon_lat_MED.nc'],'mask',mask1);\nncwrite([dirout,'lon_lat_MED.nc'],'lon',lon2d);\nncwrite([dirout,'lon_lat_MED.nc'],'lat',lat2d);\n\n% Create fields file in the right box\nsystem(['ncks -O ',dirin,inname,datename,'.nc -v longitude,latitude,time,adt ',...\n    '-d longitude,',num2str(lon1+360),'.0,',num2str(lon2+360),...\n    '.0 -d latitude,',num2str(lat1),'.0,',num2str(lat2),'.0 ',...\n    dirout,'ssh_',outname,'.nc']);\nsystem(['ncks -O ',dirin,inname,datename,'.nc -v longitude,latitude,time,ugos ',...\n    '-d longitude,',num2str(lon1+360),'.0,',num2str(lon2+360),...\n    '.0 -d latitude,',num2str(lat1),'.0,',num2str(lat2),'.0 ',...\n    dirout,'ssu_',outname,'.nc']);\nsystem(['ncks -O ',dirin,inname,datename,'.nc -v longitude,latitude,time,vgos ',...\n    '-d longitude,',num2str(lon1+360),'.0,',num2str(lon2+360),...\n    '.0 -d latitude,',num2str(lat1),'.0,',num2str(lat2),'.0 ',...\n    dirout,'ssv_',outname,'.nc']);\n\n% Change name to be used by the mod_eddy routines\nsystem(['ncrename -v time,day -v adt,ssh ',dirout,'ssh_',outname,'.nc']);\nsystem(['ncrename -v time,day -v ugos,u ',dirout,'ssu_',outname,'.nc']);\nsystem(['ncrename -v time,day -v vgos,v ',dirout,'ssv_',outname,'.nc']);")

